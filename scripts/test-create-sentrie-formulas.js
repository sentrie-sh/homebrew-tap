#!/usr/bin/env node
// SPDX-License-Identifier: Apache-2.0
//
// Copyright 2025 Binaek Sarkar
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const {
  mkdirSync,
  writeFileSync,
  rmSync,
  existsSync,
  readFileSync,
} = require("fs");
const { join } = require("path");
const { execSync } = require("child_process");

const testDir = join(__dirname, "test-tmp");
const scriptPath = join(__dirname, "create-sentrie-formulas.js");

// Test cases - only stable releases are supported
const testCases = [
  {
    name: "Stable release - full version",
    version: "v1.2.3",
    expectFormulas: [
      "sentrie.rb",
      "sentrie@1_2_3.rb",
      "sentrie@1_2.rb",
      "sentrie@1.rb",
    ],
  },
  {
    name: "Single digit version",
    version: "v5.0.0",
    expectFormulas: [
      "sentrie.rb",
      "sentrie@5_0_0.rb",
      "sentrie@5_0.rb",
      "sentrie@5.rb",
    ],
  },
  {
    name: "Double digit version",
    version: "v10.20.30",
    expectFormulas: [
      "sentrie.rb",
      "sentrie@10_20_30.rb",
      "sentrie@10_20.rb",
      "sentrie@10.rb",
    ],
  },
  {
    name: "Version starting with zero",
    version: "v0.0.1",
    expectFormulas: [
      "sentrie.rb",
      "sentrie@0_0_1.rb",
      "sentrie@0_0.rb",
      "sentrie@0.rb",
    ],
  },
  {
    name: "Version without v prefix",
    version: "2.5.8",
    expectFormulas: [
      "sentrie.rb",
      "sentrie@2_5_8.rb",
      "sentrie@2_5.rb",
      "sentrie@2.rb",
    ],
  },
  {
    name: "Version 0.0.0 (edge case)",
    version: "v0.0.0",
    expectFormulas: [
      "sentrie.rb",
      "sentrie@0_0_0.rb",
      "sentrie@0_0.rb",
      "sentrie@0.rb",
    ],
  },
  {
    name: "Large version numbers",
    version: "v99.99.99",
    expectFormulas: [
      "sentrie.rb",
      "sentrie@99_99_99.rb",
      "sentrie@99_99.rb",
      "sentrie@99.rb",
    ],
  },
  {
    name: "Version with all zeros",
    version: "v0.0.0",
    expectFormulas: [
      "sentrie.rb",
      "sentrie@0_0_0.rb",
      "sentrie@0_0.rb",
      "sentrie@0.rb",
    ],
  },
];

// Error test cases
const errorCases = [
  {
    name: "Missing VERSION env var",
    env: {},
    expectError: true,
  },
  {
    name: "Invalid version format",
    env: { VERSION: "invalid" },
    expectError: true,
  },
  {
    name: "Prerelease version (should be rejected)",
    env: { VERSION: "v1.2.3-alpha" },
    expectError: true,
  },
  {
    name: "Version with build metadata (should be rejected)",
    env: { VERSION: "v1.2.3+git.abc123" },
    expectError: true,
  },
  {
    name: "Prerelease with build metadata (should be rejected)",
    env: { VERSION: "v1.2.3-alpha+build" },
    expectError: true,
  },
  {
    name: "Empty version string",
    env: { VERSION: "" },
    expectError: true,
  },
  {
    name: "Version with only dots",
    env: { VERSION: "..." },
    expectError: true,
  },
  {
    name: "Non-numeric version",
    env: { VERSION: "vabc.def.ghi" },
    expectError: true,
  },
  {
    name: "Version with only major",
    env: { VERSION: "v1" },
    expectError: true,
  },
  {
    name: "Version with only major.minor",
    env: { VERSION: "v1.2" },
    expectError: true,
  },
  {
    name: "Version with too many parts",
    env: { VERSION: "v1.2.3.4" },
    expectError: true,
  },
  {
    name: "Version with non-numeric parts",
    env: { VERSION: "v1.2.x" },
    expectError: true,
  },
  {
    name: "Version with negative numbers",
    env: { VERSION: "v-1.2.3" },
    expectError: true,
  },
  {
    name: "Version with whitespace",
    env: { VERSION: "v1.2.3 " },
    expectError: true,
  },
];

// Test case for missing formula template (should not fail)
// Test case specifically for comment removal
const commentRemovalTestCases = [
  {
    name: "Comment removal - various comment patterns",
    version: "v2.0.0",
    expectFormulas: [
      "sentrie.rb",
      "sentrie@2_0_0.rb",
      "sentrie@2_0.rb",
      "sentrie@2.rb",
    ],
    modifyFormulaTemplate: (template) => {
      // Add various comment patterns
      return `# This file was generated by GoReleaser. DO NOT EDIT.
# typed: false
# frozen_string_literal: true
# Additional comment
  # Indented comment
${template.split("\n").slice(2).join("\n")}`;
    },
  },
];

const optionalTestCases = [
  {
    name: "Missing formula template (optional)",
    version: "v1.0.0",
    createFormulaTemplate: false,
    expectFormulas: [],
  },
];

// Test cases for template content validation (should fail)
const templateContentTestCases = [
  {
    name: "Formula template with unexpected class name",
    version: "v1.0.0",
    modifyFormulaTemplate: (template) =>
      template.replace("class Sentrie", "class Other"),
    expectError: true,
  },
  {
    name: "Formula template without class declaration",
    version: "v1.0.0",
    modifyFormulaTemplate: (template) =>
      template.replace(/^class\s+Sentrie\s+<\s+Formula/m, ""),
    expectError: true,
  },
  {
    name: "Formula template with class name in comment",
    version: "v1.0.0",
    modifyFormulaTemplate: (template) =>
      template.replace(
        /^class\s+Sentrie\s+<\s+Formula/m,
        "# class Sentrie < Formula\nclass Other < Formula"
      ),
    expectError: true,
  },
];

function setupTestDir() {
  if (existsSync(testDir)) {
    rmSync(testDir, { recursive: true, force: true });
  }
  mkdirSync(testDir, { recursive: true });
  mkdirSync(join(testDir, "Formula"), { recursive: true });
}

function createTemplateFiles(createFormula = true, modifiers = {}) {
  // Create formula template
  let formulaTemplate = `# This file was generated by GoReleaser. DO NOT EDIT.
# typed: false
# frozen_string_literal: true
formula "sentrie" do
  name "sentrie"
  desc "Sentrie policy engine"
  homepage "https://sentrie.sh"
  version "1.2.3"

  binary "sentrie"

  on_macos do
    on_intel do
      url "https://github.com/sentrie-sh/sentrie/releases/download/v#{version}/sentrie_#{version}_darwin_amd64.tar.gz",
        verified: "github.com/sentrie-sh/sentrie"
      sha256 "test123"
    end
  end
end
`;

  // Create formula template
  let formulaTemplate = `# This file was generated by GoReleaser. DO NOT EDIT.
# typed: false
# frozen_string_literal: true
class Sentrie < Formula
  desc "Sentrie policy engine"
  homepage "https://sentrie.sh"
  version "1.2.3"
  license "Apache-2.0"

  on_macos do
    on_intel do
      url "https://github.com/sentrie-sh/sentrie/releases/download/v#{version}/sentrie_#{version}_darwin_amd64.tar.gz"
      sha256 "test123"
    end
  end

  def install
    bin.install "sentrie"
  end

  test do
    system "#{bin}/sentrie", "version"
  end
end
`;

  // Apply modifiers if provided
  if (modifiers.modifyformulaTemplate) {
    formulaTemplate = modifiers.modifyformulaTemplate(formulaTemplate);
  }
  if (modifiers.modifyFormulaTemplate) {
    formulaTemplate = modifiers.modifyFormulaTemplate(formulaTemplate);
  }

  writeFileSync(join(testDir, "Formula", "sentrie.rb.tmpl"), formulaTemplate);
  if (createFormula) {
    writeFileSync(join(testDir, "Formula", "sentrie.rb.tmpl"), formulaTemplate);
  }
}

function runTest(testCase) {
  setupTestDir();
  const modifiers = {
    modifyFormulaTemplate: testCase.modifyFormulaTemplate,
  };
  createTemplateFiles(testCase.createFormulaTemplate !== false, modifiers);

  const env = {
    ...process.env,
    VERSION: testCase.version,
  };

  try {
    execSync(`node ${scriptPath}`, {
      cwd: testDir,
      env,
      stdio: "pipe",
    });

    // Check expected files exist
    const formulaDir = join(testDir, "Formula");

    // Verify templates are removed (critical - templates should never be committed)
    if (testCase.createFormulaTemplate !== false) {
      if (existsSync(join(formulaDir, "sentrie.rb.tmpl"))) {
        throw new Error("Formula template should be removed");
      }
    }

    // Check expected formula files
    for (const file of testCase.expectFormulas) {
      const path = join(formulaDir, file);
      if (!existsSync(path)) {
        throw new Error(`Expected formula file not found: ${file}`);
      }
      // Verify content for formulas
      const content = readFileSync(path, "utf8");

      if (file === "sentrie.rb") {
        // Default formula should have class Sentrie
        if (!content.includes("class Sentrie < Formula")) {
          throw new Error(`Default formula ${file} should have class Sentrie`);
        }
      } else {
        // Versioned formulas should have class SentrieAT{tokenSuffix}
        // Extract tokenSuffix from filename: sentrie@1_2_3.rb -> 1_2_3
        const tokenSuffix = file.replace(/^sentrie@/, "").replace(/\.rb$/, "");
        const expectedClassName = `SentrieAT${tokenSuffix}`;
        if (!content.includes(`class ${expectedClassName} < Formula`)) {
          throw new Error(
            `Versioned formula ${file} should have class ${expectedClassName}, but content shows: ${
              content.match(/class\s+\w+\s+<\s+Formula/)?.[0] || "not found"
            }`
          );
        }
      }
    }

    // Verify no unexpected files
    const allFormulas = require("fs")
      .readdirSync(formulaDir)
      .filter((f) => f.endsWith(".rb"));

    const unexpectedFormulas = allFormulas.filter(
      (f) => !testCase.expectFormulas.includes(f)
    );

    if (unexpectedFormulas.length > 0) {
      throw new Error(
        `Unexpected formula files: ${unexpectedFormulas.join(", ")}`
      );
    }

    // Verify file contents are not empty and have valid structure
    for (const file of testCase.expectFormulas) {
      const path = join(testDir, "Formula", file);
      if (existsSync(path)) {
        const content = readFileSync(path, "utf8");
        if (content.length === 0) {
          throw new Error(`File ${file} is empty`);
        }
        
        // Verify comment lines are removed
        const lines = content.split("\n");
        for (let i = 0; i < lines.length; i++) {
          const trimmed = lines[i].trim();
          if (trimmed.length > 0 && trimmed.startsWith("#")) {
            throw new Error(
              `File ${file} contains comment line at line ${i + 1}: ${trimmed}`
            );
          }
        }
        
        // Verify files are valid Ruby syntax (basic check)
        if (!content.includes("class")) {
          throw new Error(`Formula file ${file} missing class declaration`);
        }
        if (!content.includes("Formula")) {
          throw new Error(`Formula file ${file} missing Formula inheritance`);
        }
      }
    }

    console.log(`✓ ${testCase.name}`);
    return true;
  } catch (error) {
    console.error(`✗ ${testCase.name}: ${error.message}`);
    return false;
  }
}

function runErrorTest(errorCase) {
  setupTestDir();

  // Handle template modification for error cases
  const modifiers = {
    modifyFormulaTemplate: errorCase.modifyFormulaTemplate,
  };
  createTemplateFiles(true, modifiers);

  const env = {
    ...process.env,
    ...errorCase.env,
    VERSION: errorCase.version || errorCase.env?.VERSION,
  };

  try {
    execSync(`node ${scriptPath}`, {
      cwd: testDir,
      env,
      stdio: "pipe",
    });
    if (errorCase.expectError) {
      console.error(`✗ ${errorCase.name}: Expected error but script succeeded`);
      return false;
    } else {
      console.log(`✓ ${errorCase.name} (correctly succeeded)`);
      return true;
    }
  } catch (error) {
    if (errorCase.expectError) {
      console.log(`✓ ${errorCase.name} (correctly failed)`);
      return true;
    } else {
      console.error(`✗ ${errorCase.name}: Unexpected error: ${error.message}`);
      return false;
    }
  }
}

// Run tests
console.log("Running stress tests for create-sentrie-formulas.js\n");

let passed = 0;
let failed = 0;

console.log("=== Normal Test Cases ===");
for (const testCase of testCases) {
  if (runTest(testCase)) {
    passed++;
  } else {
    failed++;
  }
}

console.log("\n=== Error Test Cases ===");
for (const errorCase of errorCases) {
  if (runErrorTest(errorCase)) {
    passed++;
  } else {
    failed++;
  }
}

console.log("\n=== Optional Test Cases ===");
for (const testCase of optionalTestCases) {
  if (runTest(testCase)) {
    passed++;
  } else {
    failed++;
  }
}

console.log("\n=== Template Content Test Cases ===");
for (const testCase of templateContentTestCases) {
  if (runErrorTest(testCase)) {
    passed++;
  } else {
    failed++;
  }
}

console.log("\n=== Comment Removal Test Cases ===");
for (const testCase of commentRemovalTestCases) {
  if (runTest(testCase)) {
    passed++;
  } else {
    failed++;
  }
}

// Cleanup
if (existsSync(testDir)) {
  rmSync(testDir, { recursive: true, force: true });
}

console.log(`\n=== Results ===`);
console.log(`Passed: ${passed}`);
console.log(`Failed: ${failed}`);
console.log(`Total: ${passed + failed}`);

process.exit(failed > 0 ? 1 : 0);
